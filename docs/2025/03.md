# 3/30

[フロントエンド開発のためのテスト入門](https://www.amazon.co.jp/%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E9%96%8B%E7%99%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88%E5%85%A5%E9%96%80-%E4%BB%8A%E3%81%8B%E3%82%89%E3%81%A7%E3%82%82%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E8%87%AA%E5%8B%95%E3%83%86%E3%82%B9%E3%83%88%E6%88%A6%E7%95%A5%E3%81%AE%E5%BF%85%E9%A0%88%E7%9F%A5%E8%AD%98-%E5%90%89%E4%BA%95-%E5%81%A5%E6%96%87/dp/4798178187) という書籍でテストの勉強を始めてから4,5日目くらい？
昨日までで単純な関数のユニットテストの章が終わったので、今日からUIコンポーネントテストの章に入る

## <第5章> UIコンポーネントテスト

### 5-1. UIコンポーネントテストの基礎知識

そもそも、UIコンポーネントに求められる基本機能としては次のようなものが挙げられる

- データを表示すること
- ユーザー操作内容を伝播すること
- 関連するWeb APIを繋ぐこと
- データを動的に書き換えること

テスティングフレームワークやテスト用ライブラリを駆使して「機能が意図通りに動作するか？」「機能が壊れていないか？」を確認する

#### Webアクセシビリティとテスト

- ユーザーの心身特性に隔てなくWebが利用できる水準を「Webアクセシビリティ」と呼ぶ
- UIコンポーネントテストは、Webアクセシビリティを気にかけるための機会にうってつけ
- UIコンポーネントテストは基本機能を検証するだけでなく、Webアクセシビリティ品質を向上するきっかけとなる

### 5-2. 必要なライブラリのインストール

- **jest/enviroment-jsdom**
  - UIを表示して操作するためにはDOM APIが必要
  - Jest実行環境のNode.jsにはDOM APIが標準で用意されていないのでこれが必要
- **@testing-library/react**
  - Testing LibraryはUIコンポーネントのテスト用ライブラリで、主な役割は次の3つ
    - UIコンポーネントをレンダリングする
    - レンダリングした要素から、任意の子要素を取得する
    - レンダリングした要素に、インタラクションを与える
  - Reactで実装している場合、React向けの`@testing-library/react`を使用する
- **@testing-library/jest-dom**
  - UIコンポーネントテスト用のマッチャー拡張
  - Jest標準のマッチャーだけでは不十分なのでこれが必要
- **@testing-library/user-event**
  - ユーザー操作をシミュレートするライブラリ
  - Testing Libraryでは、入力要素に文字入力などを行うために`fireEvent`というAPIが提供されている
  - しかしこのAPIは、実際のユーザー操作では不可能な操作もできてしまうことがある
  - そこで、実際のユーザー操作により近いシミュレートを行うことができる`@testing-library/user-event`を追加する

> [!note]
> 実際テストを書くときは`Jest`ではなく`Vitest`を使うことを想定しているので、多少ライブラリは違うものになりそう

### 5-3. はじめのUIコンポーネントテスト

#### 特定のDOM要素を取得する

- レンダリングした内容から特定のDOM要素を取得するために、`screen.getByText`を使用する
- これは「一致した文字列を持つテキスト要素を1つ見つける」API
- 見つかった場合はその要素の参照が得られ、見つからなかった場合はエラーが発生しテストは落ちる

#### アサーションを書く

- `toBeInTheDocument()`は「要素がドキュメントに存在すること」を検証するカスタムマッチャー

#### 特定のDOM要素をロールで取得する

- 特定のDOM要素をロールで取得するために、`screen.getByRole`を使用する
- 「暗黙的なロール」の識別もしてくれる（下記の例では`<button>`要素に明示的にbuttonロールを指定していない）
  ```ts
  test("ボタンの表示", () => {
    render(<Form name="taro">);
    expect(screen.getByRole("button")).toBeDocument();
  });
  ```

#### 見出しのアサーション

- `h1〜h6`は、暗黙的なロールとして`heading`ロールを持つ
- 取得した見出し要素に、期待するテキストが含まれているかをテスト

  - `toHaveTextContent`マッチャーで検証できる

  ```ts
  test("見出しの表示", () => {
    render(<Form name="taro">);
    expect(screen.getByRole("heading")).(toHaveTextContent("アカウント情報"));
  });
  ```

<!-- prettier-ignore -->
> [!note]
> **Testing Libraryの基本原則**
> 「暗黙的なロール」も含めたクエリーを優先的に使用することを推奨

#### イベントハンドラー呼び出しのテスト

- イベントハンドラーの呼び出しは、関数の単体テストと同様にモック関数を利用する

  ```ts
  test("ボタンを押下すると、イベントハンドラーが呼ばれる", () => {
    // Arrange
    const mockFn = jest.fn();
    render(<Form name="taro" onSubmit={mockFn} />);
    // Act
    fireEvent.click(screen.getByRole("button"));
    // Assert
    expect(mockFn).toHaveBeenCalled();
  });
  ```

  - 上の例では`fireEvent`を使ってDOMのイベントを発火させてるけど`useEvent`使う方が一般的?

  ```ts
  const user = userEvent.setup();

  test("ボタンを押下すると、イベントハンドラーが呼ばれる", async () => {
    // Arrange
    const mockFn = jest.fn();
    render(<Form name="taro" onSubmit={mockFn} />);
    // Act
    await user.click(screen.getByRole("button"));
    // Assert
    expect(mockFn).toHaveBeenCalled();
  });
  ```

### 5-4. アイテム一覧UIコンポーネントテスト

- `getAllByRole` ・・・ 該当要素を配列で取得するAPI
- `<li>`要素は暗黙のロールとして`listitem`を持つ
- `toHaveLength` ・・・ 配列の要素数を検証するマッチャー
- `<ul>`要素は暗黙のロールとして`list`を持つ

#### within関数で絞り込む

- 対象を絞り込んで、要素取得を行うことができる
  ```ts
  test("items の数だけ一覧表示される", () => {
    // Arrange
    render(<ArticleList items={items} />);
    // Act
    const list = screen.getByRole("list");
    // Assert
    expect(list).toBeInTheDocument();
    // `list` の中に `listitem` が 3 つあることを確認したいので
    // `within` を使って `list` の中に絞って確認する
    expect(within(list).getAllByRole("listitem")).toHaveLength(3);
  });
  ```

#### 表示されないことをテストする

- `getByRole`や`getByLabelText`などは存在しない要素取得を試みた場合、エラーが発生する
- そのため、「存在しないこと」を検証したいときは、`queryBy`接頭辞を持つAPIを使用する
- `queryBy`接頭辞を持つAPIはエラー発生でテストが中断されることがない
- 取得できなかった場合`null`が返ってくるため、`not.toBeInTheDocument`または`toBeNull`マッチャーで検証できる

```ts
test("一覧アイテムが空のとき「投稿記事がありません」が表示される", () => {
  // Arrange
  render(<ArticleList items={[]} />);
  // Act
  const list = screen.queryByRole("list");
  // Assert
  // `not.toBeInTheDocument` と `toBeNull` は同じことを検証するのでどちらかでいい
  expect(list).not.toBeInTheDocument();
  expect(list).toBeNull();
  expect(screen.getByText("投稿記事がありません")).toBeInTheDocument();
});
```

#### 要素の属性を調べる

- 要素の属性を調べるには、`toHaveAttribute`マッチャーで検証する

```ts
test("ID に紐づいたリンクが表示される", () => {
  // Arrange
  // Act
  render(<ArticleListItem {...item} />);
  // Assert
  expect(screen.getByRole("link", { name: "もっと見る" })).toHaveAttribute(
    "href",
    "/articles/howto-testing-with-typescript"
  );
});
```

#### クエリー（要素取得API）の優先順位

- 「ユーザー操作を限りなく再現する」ことが、Testing Libraryのコーディング原則
- この原則にならい、要素取得APIは次の優先順位で使用することが推奨されている

1. 誰でもアクセスできるクエリー

- getByRole
- getByLabelText
- getByPlaceholderText
- getByText
- getByDisplayName

2. セマンティッククエリー

- getByAltText
- getByTitle

3. テストID

- getByTestId

### 5-5. インタラクティブなUIコンポーネントテスト

- アクセシブルネームの引用

  - `<fieldset>`要素は、暗黙のロールとして`group`ロールを持つ
  - `<legend>`要素は、`<feildset>`要素の子要素として使用するもので、グループのタイトルをつけるための要素

- checkboxの初期状態を検証
  - checkboxの状態をカスタムマッチャー`toBeChecked`で検証する

#### UserEventで文字を入力する

- はじめに、`userEvent.setup()`でAPIを呼び出すuserインスタンスを作成する
- `<input type="text" />`は、暗黙の`textbox`ロールを持つ
- `userEvent`を使用したインタラクションは全て、操作が完了するまで待つ必要がある非同期処理なので、`await`で入力完了を待つ
- 入力フィールドの値は`getByText`ではなく`getByDisplayValue`で取得する

```ts
const user = userEvent.setup();

test("メールアドレス入力欄", async () => {
  // Arrange
  render(<InputAccount />);
  const textbox = screen.getByRole("textbox", { name: "メールアドレス" });
  const value = "taro.tanaka@example.com";
  // Act
  await user.type(textbox, value);
  // Assert
  // 入力フィールドの値は`getByText`ではなく`getByDisplayValue`で取得する
  expect(screen.getByDisplayValue(value)).toBeInTheDocument();
});
```

<!-- prettier-ignore -->
> [!note]
> <b>パスワードを入力する際の注意</b>
> - <input type="password" />はロールを持たない

#### UserEventで要素をクリックする

- `user.click(要素)`を使用する
  - ex.) user.click(screen.getByRole("checkbox"))

#### ボタンの活性/非活性を検証する

- toBeDisabled
- toBeEnabled

#### formのアクセシブルネーム

以下のフォームのアクセシブルネームは、headingロールである`<h2>`要素の文字列を引用している

- `aria-labelledby`属性に`<h2>`要素のIDを指定することで、アクセシブルネームとして引用させている
- HTML要素のid属性は、ドキュメント内で一意である必要がある
- 重複しないように管理するのは難しいので、自動生成・自動管理に`useId`が便利

```ts
import { useId, useState } from "react";
import { Agreement } from "./Agreement";
import { InputAccount } from "./InputAccount";

export const Form = () => {
  const [checked, setChecked] = useState(false);
  const headingId = useId();
  return (
    // `aria-labelledby` に<h2>要素の`id`を指定することで、
    // フォームのラベルを<h2>要素のテキストにすることができる
    // HTML要素の`id`属性はドキュメント内で一意である必要がある
    // `useId`を使うと一意の`id`を生成することができるので自動生成・自動管理に便利
    <form aria-labelledby={headingId}>
      <h2 id={headingId}>新規アカウント登録</h2>
      <InputAccount />
      <Agreement
        onChange={(event) => {
          setChecked(event.currentTarget.checked);
        }}
      />
      <div>
        <button disabled={!checked}>サインアップ</button>
      </div>
    </form>
  );
};
```

<!-- prettier-ignore -->
> [!note]
> アクセシブルネームを与えることで、`<form>`要素に`form`ロールが適用される
> ※ アクセシブルネームがない場合はロールを持たない
> ```ts
> test("form のアクセシブルネームは、見出しを引用している", () => {
>     // Arrange
>     // Act
>     render(<Form />);
>     // Assert
>     expect(
>       screen.getByRole("form", { name: "新規アカウント登録" })
>     ).toBeInTheDocument();
>   });
> ```
